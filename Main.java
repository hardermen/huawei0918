package 笔试题2019.华为.秋招手撕题;
/**
      二面面试官出的题目他自己并没有深入研究，我的解题思路本身正确，而面试官却最终给我引导到了错误答案，面试官认为我的思维不对，我对这点非常不满意。面试官一次判定决定面试者的人生命运，拿着自己出的题目的错误答案去判定我的思路错误，显然很不负责！
面试官题目概要如下：
       有一些任务标记为A-Z，如{A，A，A，A, A,B，B,B},规定每次只能做1个任务花费1个时间，两个相同任务之间必须相隔N时间或者以上，如果不能满足，就用空格代替，表示消耗了一个时间，求最终完成所有任务的时间。
例子：上面的情况如果N=2     最终排的任务如下：AB空AB空AB空A空空A
面试官的答案：（最多字符A的个数-1）*（N+1）+1     
我的答案：
（1）每次维护所有相同字符个数，如上面只有AB那么就直接装数组arr =【5,3】表示A（对应数组0位置）有5个，B（对应1位置）有3个，
（2）然后按照时间来进行选择任务做，维护当前可用字符的情况【1,0】，1表示对应位置A已经被上一个选择了，1的值没有大于N=2，所以此步不能选，但是后面0数字表示B没有被选择，当前位置可以选择，选择之后将0变成1，循环下一次时间加1，每次循环非0位置都要加一，满3变成0，也就是3进制数。
（3）第（2）步是判定了哪些可以选，如果都不能选就放“空”消耗一个时间，若可放的任务很多，那这时候第（1）步维护的个数就派上用场，找出可选的任务剩余最多的个数，此步就选这个！选定之后将（1）数组的个数减去1，将（2）数组的可选时间加1
（4）数组（2）中当前可选的一定是标记为0的，当前步骤选到的位置从0变成1，然后将所有标记非0的数字加1，若超过了N值，变回0，表示可选。
(5)循环完成，最终（1）中数组全部变成0，表示循环结束，此时时间值就是所有时间！

    面试过程做题时，我说出我的正确思路，面试官没有深入分析我的思路，直接问我答案是什么，我抓耳挠腮思考了很长时间，然后我说不一定，他一直给我引导，说和数量最多的字母的个数的关系是什么？和约束的N值关系是什么？他心中很确定这道题得答案只与n值和最长任务的数量m有关
然后觉得我不能理解他的意思，用极限法给我说，你把N变成1万，然后得出什么结论？然后我才慢慢领会了面试官的意思，他就是想说答案就是（最多任务字符A的个数-1）*（N+1）+1 ，最后他得意洋洋的说答案就是这个，这个题考查的是你思维问题的方式，
然后他就说面试结束了。。。在路上我想了一下，面试官这推理，如果N=0，如果N为一般值，这个公式有什么用？他考虑的是极端的情况，但是本题的答案并不和面试官说的一样，我说的思路是正确的，为什么面试官就一直不愿意听我的正确思路？反而拿着错误的结论来批评我的思维方式呢？？？
说是要考查面试者的思维方式，不是不行，您出一个完全用思维可以解决漂亮的题目不行 吗？用极限思维不能解决该问题，解决答案是错误的，那极限思维在这个题目就是不适用的！

面试过程我只是说出我的思路，面试官评价任认为不对，所以一直在引导我往他的错误答案上，所以代码并没有留存到面试白纸上！
我的联系方式：nanyou2025@163.com     希望面试我的面试官能给出合理解释！若是我的分析有误，烦请解答！ 若是我的分析正确，烦请给我公正的评判！
我按照自己解决思路完成的正确代码：  https://github.com/hardermen/huawei0918.git
 *
 */
public class Main {
	public static void main(String[] args) {
		int N = 3;
		//char[] chrr = {'A','A','A','B','B','C','C','D','D','E','E'};
		//先找出字母的种数，非常简单，按照顺序维护每种字母的个数，从A到E按照顺序。代码不写了，直接new数组，里面按照字母表的顺序表示A有3个。。。
		int[] nums = {3,2,2,2,2};
		//再维护和上面数组长度一致的，可用与否的数组，0表示当前可用，1表示上一次刚用过此字母，2表示隔一个，3表示隔两个，4表示隔三个了，此时可用，也就是4转回0，也就是这个数组是N进制的！
		int[] usable = {0,0,0,0,0};
		int time =0;
		//下面开始循环，time每次加1
		while(check(nums)) {
			int maxIndex = 0;
			int maxCount = 0;
			//下面找到当前所有的可用位置，并且挑出当前所有可用位置中，值最大的可用位置！
			for(int i = 0; i < usable.length; i++) {
				if(usable[i]==0) {
					if(maxCount < nums[i]) {
						maxCount = nums[i];
						maxIndex = i;
					}
				}
			}
			//下面判断当前挑出的位置，是否可用，如果不可用，维护一下usable列表，打印空
			if(nums[maxIndex]==0||usable[maxIndex]!=0) {
				for(int i = 0; i < usable.length; i++) {
					if(usable[i]>0) {
						if(usable[i]==N) {
							usable[i]=0;
						}else {
							usable[i]++;
						}
					}
				}
				System.out.print("空");
				
				//下面是如果可用，维护一下nums数组，并且维护一下usable数组，打印出当前挑选的数。
			}else {
				nums[maxIndex]--;
				for(int i = 0; i < usable.length; i++) {
					if(usable[i]>0) {
						if(usable[i]==N) {
							usable[i]=0;
						}else {
							usable[i]++;
						}
					}
				}
				usable[maxIndex]=1;	
				System.out.print(maxIndex);
			}
			time++;
		}
		//遍历完成，得出答案！
		System.out.println("\n"+time);
	}

	private static boolean check(int[] nums) {
		for(int i = 0; i < nums.length; i ++) {
			if(nums[i] != 0) {
				return true;
			}
		}
		return false;
	}
}
